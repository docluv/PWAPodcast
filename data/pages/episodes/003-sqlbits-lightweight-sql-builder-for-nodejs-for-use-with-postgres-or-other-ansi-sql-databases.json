{"Name":"Podstr","LongName":"Podstr","lowerAppName":"Podstr","slug":"003-sqlbits-lightweight-sql-builder-for-nodejs-for-use-with-postgres-or-other-ansi-sql-databases","title":"003 SQLBits - lightweight SQL builder for Node.js for use with Postgres or other ANSI SQL databases","description":"<p>SQLBits, a lightweight SQL builder for Node.js built by <a href=\"https://github.com/williamwicks\" title=\"William Wicks GitHub prifile\">William Wicks</a>, is a great compromise between using native SQL and going to a full ORM (object relational mapping tool). It is small and focused on doing one job, to help you create parameterized queries. One of its unique and killer features is that it can help you create any combination of filter queries from a single complex query based on the parameters used.</p>\n<p>My goal with this podcast is to introduce you to <a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a> and provide some insight as to why it could be a valuable tool in your Node.js toolbox.</p>\n<div id=\"toc\"><ol><li><a href=\"#episode_info\">Episode Info</a></li><li><a href=\"#episode_notes\">Episode Notes</a><ol><li><a href=\"#background_-_sql_builder_vs_orm\">Background - SQL Builder vs ORM</a></li><li><a href=\"#sqlbits_-_node_js_sql_builder\">SQLBits - Node.js SQL builder</a></li><li><a href=\"#sqlbits_install\">SQLBits Install</a></li><li><a href=\"#simple_example\">Simple example</a></li><li><a href=\"#additional_criteria\">Additional criteria</a></li><li><a href=\"#joins\">Joins</a></li><li><a href=\"#filters_driven_by_defined_parameters\">Filters driven by defined parameters</a></li><li><a href=\"#inserts\">Inserts</a></li><li><a href=\"#updates\">Updates</a></li><li><a href=\"#deletes\">Deletes</a></li></ol></li><li><a href=\"#quick_reference\">Quick Reference</a></li><li><a href=\"#resources\">Resources</a></li><li><a href=\"#summary\">Summary</a></li></ol></div>\n\n<a name=\"episode_info\"></a><h2 id=\"episode-info\">Episode Info</h2>\n<ul>\n<li>Episode: CW 003</li>\n<li>Published: February 17th, 2014</li>\n<li>Tags: nodejs, database</li>\n<li>Duration: 17:17</li>\n</ul>\n<a name=\"episode_notes\"></a><h2 id=\"episode-notes\">Episode Notes</h2>\n<a name=\"background_-_sql_builder_vs_orm\"></a><h3 id=\"background-sql-builder-vs-orm\">Background - SQL Builder vs ORM</h3>\n<p>What is a SQL builder and how does that compare to an ORM (Object Relational Mapper)?</p>\n<p>A SQL builder like SQLBits is designed to help you to build safe parameterized SQL with a minimal abstraction layer that still allows you to write optimized SQL queries. Using parameters is important in create SQL to prevent SQL injection attacks where users enter malicious data into forms to gain access to your database. SQL builders help you to use parameters and avoid these attacks.</p>\n<p>Having used Hibernate for Java and Active Record with Rails (a couple of popular Object Relational Mappers, I’ve seen what a ORM’s can do and they are nice when they do what you want, but all to often once you get into more advanced uses, they tend to get in your way and you are fighting with the tool to try to get it to generate the SQL you want.</p>\n<p>So a SQL builder which allows you to create just the right queries but helps you deal with parameterization and tokens, provides a great balance. It stays out of your way and just helps with the bookkeeping. The sql it generates and the parameter array can be used directly with your database module like the <code>pg</code> Postgres client.</p>\n<a name=\"sqlbits_-_node_js_sql_builder\"></a><h3 id=\"sqlbits-node-js-sql-builder\">SQLBits - Node.js SQL builder</h3>\n<p>I reviewed a bunch of Node.js SQL builders listed in NPM and I was not happy with any of them until I found <a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a>.</p>\n<p>Too many of them seemed complicated or too integrated bordering on ORM capabilities. I wanted something that was simple and just server a single purpose to help me build good parameterized queries. I didn’t want it to run my queries or perform schema manipulation. I don’t want a complete new DSL (domain specific language) or API that I need to learn. SQL is already a DSL that does that just fine, but it can get tricky to manage as queries get complex.</p>\n<p>SQLBits is a simple tool which helps you generate SQL but stays out of your way. You can create custom tuned SQL which pulls back only what is needed over the wire and have it manage the parameters and tokens.</p>\n<a name=\"sqlbits_install\"></a><h3 id=\"sqlbits-install\">SQLBits Install</h3>\n<pre class=\"highlight\"><code class=\"hljs bash\">npm install sqlbits --save  <span class=\"hljs-comment\"># install and add to package.json</span>\n</code></pre>\n<a name=\"simple_example\"></a><h3 id=\"simple-example\">Simple example</h3>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> $ = bits.$;\n<span class=\"hljs-keyword\">var</span> AND = bits.AND;\n<span class=\"hljs-keyword\">var</span> params = { <span class=\"hljs-attr\">max_price</span>: <span class=\"hljs-number\">10.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> };\n<span class=\"hljs-keyword\">var</span> query =\n  SQL(<span class=\"hljs-string\">'select name, desc from widgets'</span>)\n   .WHERE(<span class=\"hljs-string\">'price &lt; '</span>, $(params.max_price), AND,\n          <span class=\"hljs-string\">'clearance = '</span>, $(params.clearance))\n   .ORDERBY(<span class=\"hljs-string\">'name asc'</span>);\n\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE(price &lt; $1 AND clearance = $2) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 10, true ]</span>\n</code></pre>\n<a name=\"additional_criteria\"></a><h3 id=\"additional-criteria\">Additional criteria</h3>\n<p>You can add in additional filter criteria with:</p>\n<ul>\n<li><code>AND</code> - bits.AND</li>\n<li><code>OR</code> - bits.OR</li>\n<li><code>BETWEEN</code> - bits.BETWEEN (discussed in depth later)</li>\n<li><code>.IN(array)</code></li>\n<li><code>$</code> - bits.$ - used to specify that something is a parameter <code>$(params.foo)</code></li>\n</ul>\n<a name=\"joins\"></a><h3 id=\"joins\">Joins</h3>\n<p>With relational data, you will often need to join tables together, and to maintain good performance these joins may need to be optimized. SQLBits allows you to perform any joins you need (left, right, inner, outer) just like you would normally with raw SQL.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> query =\n  SQL(<span class=\"hljs-string\">'select w.name, c.type from widgets w '</span> +\n      <span class=\"hljs-string\">'join category c on w.categoryID = c.categoryID'</span>)\n    .ORDERBY(<span class=\"hljs-string\">'w.name asc'</span>);\n\n<span class=\"hljs-comment\">// OR</span>\n\n<span class=\"hljs-keyword\">var</span> query =\n  SQL(<span class=\"hljs-string\">'select w.name, c.type from widgets w'</span>)\n    ._(<span class=\"hljs-string\">'join category c on w.categoryID = c.categoryID'</span>)\n    .ORDERBY(<span class=\"hljs-string\">'w.name asc'</span>);\n\n<span class=\"hljs-comment\">// sql: select w.name, c.type from widgets w join category c on w.categoryID = c.categoryID ORDER BY w.name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n</code></pre>\n<p>The <code>._()</code> is another way to concatenate sql together.</p>\n<a name=\"filters_driven_by_defined_parameters\"></a><h3 id=\"filters-driven-by-defined-parameters\">Filters driven by defined parameters</h3>\n<p>If you have ever had to create SQL with filter clauses that was driven by user input, you should really appreciate this next feature.</p>\n<p>Let’s say for instance that you have a report or catalog that you want to allow the user to provide filter criteria to limit by.</p>\n<ul>\n<li>If the user doesn’t enter any criteria then return the whole list unfiltered.</li>\n<li>If they add a minimum price use that in the filter</li>\n<li>If they add a maximum price limit the rows with that criteria</li>\n<li>If they include a clearance boolean, use that in the criteria</li>\n</ul>\n<p>Even in this simple example, there are many combinations of possible filters depending on whether the user enters any of the filter data points.</p>\n<p>If you were building this SQL by hand, typically you would create a series of <code>if</code> statements to conditionally include the filter, and you would build up an array of params which you have to manually keep track of.</p>\n<p>However with SQLBits this is child’s play. You only have to create one complex query that includes all the possible filter criteria, and SQLBits will eliminate the parts where the parameters involved are <code>undefined</code>.</p>\n<p>Also by using the <code>BETWEEN</code> command, SQLBits handles all four scenarios automatically:</p>\n<ul>\n<li>min and max are defined: <code>price BETWEEN $1 AND $2</code></li>\n<li>only min is defined: <code>price &gt;= $1</code></li>\n<li>only max is defined: <code>price &lt;= $1</code></li>\n<li>neither min or max is defined: the criteria is eliminated</li>\n</ul>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> $ = bits.$;\n<span class=\"hljs-keyword\">var</span> AND = bits.AND;\n<span class=\"hljs-keyword\">var</span> BETWEEN = bits.BETWEEN;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">queryByParam</span>(<span class=\"hljs-params\">params</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> query =\n    SQL(<span class=\"hljs-string\">'select name, desc from widgets'</span>)\n      .WHERE(<span class=\"hljs-string\">'price'</span>, BETWEEN(params.min, params.max), AND,\n             <span class=\"hljs-string\">'clearance = '</span>, $(params.clearance))\n      .ORDERBY(<span class=\"hljs-string\">'name asc'</span>);\n  <span class=\"hljs-keyword\">return</span> query;\n}\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE(price BETWEEN $1 AND $2 AND clearance = $3) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, 10, true ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price &gt;=$1 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2 ];</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price &lt;=$1 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 10 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price BETWEEN $1 AND $2 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, 10 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> });\n<span class=\"hljs-comment\">// sql:  select name, desc from widgets WHERE(price &gt;=$1 AND clearance = $2) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, true ]</span>\n</code></pre>\n<p>In my opinion, this is one of the killer features of SQLBits. You create a single complex query with all the possible filters and then just provide a params object to SQLBits with a parameters object having the keys that the user wants to filter by, and it provides the customized query.</p>\n<p>This eliminates all the conditional logic which is hard to test and debug when it fails and you are left with a single complex query to maintain.</p>\n<a name=\"inserts\"></a><h3 id=\"inserts\">Inserts</h3>\n<p>Inserting data into your tables by key is as simple as providing an object to SQLBits and it will add all the keys and values.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> INSERT = bits.INSERT;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertWidget</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> INSERT.INTO(<span class=\"hljs-string\">'widgets'</span>, obj);\n}\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-attr\">desc</span>: <span class=\"hljs-string\">'Foo man'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">23.45</span> });\n<span class=\"hljs-comment\">//INSERT INTO widgets (name,desc,price) SELECT $1,$2,$3</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 'foo', 'Foo man', 23.45 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">11.23</span> });\n<span class=\"hljs-comment\">//INSERT INTO widgets (name,price) SELECT $1,$2</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 'bar', 11.23 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span> });\n<span class=\"hljs-comment\">// INSERT INTO widgets (name) SELECT $1</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: ['bar']</span>\n</code></pre>\n<a name=\"updates\"></a><h3 id=\"updates\">Updates</h3>\n<p>Updating data works just like the inserts but uses the <code>UPDATE</code> and <code>.SET()</code></p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> UPDATE = bits.UPDATE;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateWidget</span>(<span class=\"hljs-params\">id, updateValues</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> UPDATE(<span class=\"hljs-string\">'widget'</span>)\n           .SET(updateValues)\n           ._(<span class=\"hljs-string\">'where id='</span>, $(id));\n}\n\n<span class=\"hljs-keyword\">var</span> query = updateWidget(<span class=\"hljs-number\">1</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span> });\n<span class=\"hljs-comment\">// sql:  UPDATE widget SET name=$1 where id=$2</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 'bar', 1 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = updateWidget(<span class=\"hljs-number\">2</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">1.12</span> });\n<span class=\"hljs-comment\">// UPDATE widget SET name=$1,price=$2 where id=$3</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 'cat', 1.12, 2 ]</span>\n</code></pre>\n<p>Note: with update’s we don’t want to have the WHERE clause collapse so it is safer to use a non-conditional string with <code>._(&#39;where id = &#39;, $(obj.id))</code> to there is no chance of the filter clause being collapsed.</p>\n<a name=\"deletes\"></a><h3 id=\"deletes\">Deletes</h3>\n<p>Finally deletes use <code>DELETE.FROM</code> to specify a deletion.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> DELETE = bits.DELETE;\n<span class=\"hljs-keyword\">var</span> params = { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">10</span> };\n\n<span class=\"hljs-keyword\">var</span> query = DELETE.FROM(<span class=\"hljs-string\">'widgets'</span>)\n              ._(<span class=\"hljs-string\">'where id='</span>, $(params.id));\n\n<span class=\"hljs-comment\">// sql: DELETE FROM widgets where id=$1</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 10 ]</span>\n</code></pre>\n<p>Note: with delete’s we don’t want to have the WHERE clause collapse so it is safer to use a non-conditional string with <code>._(&#39;where id = &#39;, $(obj.id))</code> to there is no chance of the filter clause being collapsed.</p>\n<a name=\"quick_reference\"></a><h2 id=\"quick-reference\">Quick Reference</h2>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL; <span class=\"hljs-comment\">// SQL('select name, desc from widgets')</span>\n<span class=\"hljs-keyword\">var</span> $ = bits.$; <span class=\"hljs-comment\">// SQL('...').WHERE('id=', $(obj.id));</span>\n<span class=\"hljs-keyword\">var</span> AND = bits.AND; <span class=\"hljs-comment\">// .WHERE('id=', $(obj.id), AND, 'type=', $(obj.type));</span>\n<span class=\"hljs-keyword\">var</span> OR = bits.OR; <span class=\"hljs-comment\">// .WHERE('type=', $(obj.type), OR, 'color=', $(obj.color));</span>\n<span class=\"hljs-keyword\">var</span> IN = bits.IN; <span class=\"hljs-comment\">// .WHERE('id', IN(array));</span>\n<span class=\"hljs-keyword\">var</span> BETWEEN = bits.BETWEEN; <span class=\"hljs-comment\">// .WHERE(price, BETWEEN($(obj.min), $(obj.max));</span>\n<span class=\"hljs-keyword\">var</span> INSERT = bits.INSERT; <span class=\"hljs-comment\">// INSERT.INTO('widgets', obj)</span>\n<span class=\"hljs-keyword\">var</span> UPDATE = bits.UPDATE; <span class=\"hljs-comment\">// UPDATE('widgets').SET(updateValues)._('where id = ', $(obj.id))</span>\n<span class=\"hljs-keyword\">var</span> DELETE = bits.DELETE; <span class=\"hljs-comment\">// DELETE.FROM('widgets')._('where id = ', $(obj.id))</span>\n</code></pre>\n<p>Methods to help chain</p>\n<ul>\n<li><code>._()</code> - appends to the SQL after adding a space</li>\n<li><code>.WHERE(...)</code> - add a <code>where</code> clause which checks the params that are defined to conditionally add the filter criteria</li>\n<li><code>.SET(updateValues)</code> - used with <code>UPDATE</code> to provide the field names and values to update</li>\n<li><code>.FROM(&#39;mytable&#39;)</code> - used with <code>DELETE</code> to specify table</li>\n<li><code>.ORDERBY(&#39;name asc, qty desc&#39;)</code> - add sorting criteria</li>\n<li><code>.LIMIT(number)</code> - limit the max rows returned, defaults to 0</li>\n<li><code>.OFFSET(number)</code> - start rows at offset (for paging), defaults to 0</li>\n</ul>\n<p>Accessor properties</p>\n<ul>\n<li><code>.sql</code> - get the parameterized SQL string</li>\n<li><code>.params</code> - get the array of parameters to use with the SQL</li>\n</ul>\n<a name=\"resources\"></a><h2 id=\"resources\">Resources</h2>\n<ul>\n<li><a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a> - GitHub repo and project readme. This brief page provides examples of how to use SQLBits and is a great place to get started</li>\n</ul>\n<a name=\"summary\"></a><h2 id=\"summary\">Summary</h2>\n<p>SQLBits is a nice lightweight way to create safe parameterized SQL for Postgres or other ANSI SQL databases. It focuses on simply helping you build the SQL by managing the parameterization process, but you can still use the full power of SQL to create optimized queries and even special features that a particular SQL engine provides.</p>\n<p>One of its killer features is the ability to create custom filter queries based on whether parameters are defined, so you can create one complex query which is relaxed based on the parameters defined at runtime.</p>\n<p>Check out SQLBits, and let me know what you think. You can leave a comment in the discussion secion of this episode. I find it to be a great tool to help me generate SQL for Postgres and hope you will too.</p>","layout":"default","app-shell":"app","body":"<div class=\"container\">  <div class=\"row\">\r\n    <figure class=\"productbox\">\r\n      <div class=\"img-box\">\r\n        <img src=\"http://codewinds.com/assets/codewinds/codewinds-podcast-300.png\" alt=\"003 SQLBits - lightweight SQL builder for Node.js for use with Postgres or other ANSI SQL databases\" class=\"img-responsive\">\r\n      </div>\r\n      <figcaption>\r\n        <h3>003 SQLBits - lightweight SQL builder for Node.js for use with Postgres or other ANSI SQL databases</h3>\r\n      </figcaption>\r\n      <i class=\"fa fa-plus\" aria-hidden=\"true\"></i>\r\n    </figure>\r\n  </div>\r\n  <div class=\"row\">\r\n    <audio src=\"https://api.spreaker.com/download/episode/8734727/ep105_mixdown.mp3\" controls=\"controls\"></audio>\r\n  </div>\r\n  <div class=\"row\">\r\n    <p><p>SQLBits, a lightweight SQL builder for Node.js built by <a href=\"https://github.com/williamwicks\" title=\"William Wicks GitHub prifile\">William Wicks</a>, is a great compromise between using native SQL and going to a full ORM (object relational mapping tool). It is small and focused on doing one job, to help you create parameterized queries. One of its unique and killer features is that it can help you create any combination of filter queries from a single complex query based on the parameters used.</p>\n<p>My goal with this podcast is to introduce you to <a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a> and provide some insight as to why it could be a valuable tool in your Node.js toolbox.</p>\n<div id=\"toc\"><ol><li><a href=\"#episode_info\">Episode Info</a></li><li><a href=\"#episode_notes\">Episode Notes</a><ol><li><a href=\"#background_-_sql_builder_vs_orm\">Background - SQL Builder vs ORM</a></li><li><a href=\"#sqlbits_-_node_js_sql_builder\">SQLBits - Node.js SQL builder</a></li><li><a href=\"#sqlbits_install\">SQLBits Install</a></li><li><a href=\"#simple_example\">Simple example</a></li><li><a href=\"#additional_criteria\">Additional criteria</a></li><li><a href=\"#joins\">Joins</a></li><li><a href=\"#filters_driven_by_defined_parameters\">Filters driven by defined parameters</a></li><li><a href=\"#inserts\">Inserts</a></li><li><a href=\"#updates\">Updates</a></li><li><a href=\"#deletes\">Deletes</a></li></ol></li><li><a href=\"#quick_reference\">Quick Reference</a></li><li><a href=\"#resources\">Resources</a></li><li><a href=\"#summary\">Summary</a></li></ol></div>\n\n<a name=\"episode_info\"></a><h2 id=\"episode-info\">Episode Info</h2>\n<ul>\n<li>Episode: CW 003</li>\n<li>Published: February 17th, 2014</li>\n<li>Tags: nodejs, database</li>\n<li>Duration: 17:17</li>\n</ul>\n<a name=\"episode_notes\"></a><h2 id=\"episode-notes\">Episode Notes</h2>\n<a name=\"background_-_sql_builder_vs_orm\"></a><h3 id=\"background-sql-builder-vs-orm\">Background - SQL Builder vs ORM</h3>\n<p>What is a SQL builder and how does that compare to an ORM (Object Relational Mapper)?</p>\n<p>A SQL builder like SQLBits is designed to help you to build safe parameterized SQL with a minimal abstraction layer that still allows you to write optimized SQL queries. Using parameters is important in create SQL to prevent SQL injection attacks where users enter malicious data into forms to gain access to your database. SQL builders help you to use parameters and avoid these attacks.</p>\n<p>Having used Hibernate for Java and Active Record with Rails (a couple of popular Object Relational Mappers, I’ve seen what a ORM’s can do and they are nice when they do what you want, but all to often once you get into more advanced uses, they tend to get in your way and you are fighting with the tool to try to get it to generate the SQL you want.</p>\n<p>So a SQL builder which allows you to create just the right queries but helps you deal with parameterization and tokens, provides a great balance. It stays out of your way and just helps with the bookkeeping. The sql it generates and the parameter array can be used directly with your database module like the <code>pg</code> Postgres client.</p>\n<a name=\"sqlbits_-_node_js_sql_builder\"></a><h3 id=\"sqlbits-node-js-sql-builder\">SQLBits - Node.js SQL builder</h3>\n<p>I reviewed a bunch of Node.js SQL builders listed in NPM and I was not happy with any of them until I found <a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a>.</p>\n<p>Too many of them seemed complicated or too integrated bordering on ORM capabilities. I wanted something that was simple and just server a single purpose to help me build good parameterized queries. I didn’t want it to run my queries or perform schema manipulation. I don’t want a complete new DSL (domain specific language) or API that I need to learn. SQL is already a DSL that does that just fine, but it can get tricky to manage as queries get complex.</p>\n<p>SQLBits is a simple tool which helps you generate SQL but stays out of your way. You can create custom tuned SQL which pulls back only what is needed over the wire and have it manage the parameters and tokens.</p>\n<a name=\"sqlbits_install\"></a><h3 id=\"sqlbits-install\">SQLBits Install</h3>\n<pre class=\"highlight\"><code class=\"hljs bash\">npm install sqlbits --save <span class=\"hljs-comment\"># install and add to package.json</span>\n</code></pre>\n<a name=\"simple_example\"></a><h3 id=\"simple-example\">Simple example</h3>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> $ = bits.$;\n<span class=\"hljs-keyword\">var</span> AND = bits.AND;\n<span class=\"hljs-keyword\">var</span> params = { <span class=\"hljs-attr\">max_price</span>: <span class=\"hljs-number\">10.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> };\n<span class=\"hljs-keyword\">var</span> query =\n SQL(<span class=\"hljs-string\">'select name, desc from widgets'</span>)\n  .WHERE(<span class=\"hljs-string\">'price &lt; '</span>, $(params.max_price), AND,\n     <span class=\"hljs-string\">'clearance = '</span>, $(params.clearance))\n  .ORDERBY(<span class=\"hljs-string\">'name asc'</span>);\n\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE(price &lt; $1 AND clearance = $2) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 10, true ]</span>\n</code></pre>\n<a name=\"additional_criteria\"></a><h3 id=\"additional-criteria\">Additional criteria</h3>\n<p>You can add in additional filter criteria with:</p>\n<ul>\n<li><code>AND</code> - bits.AND</li>\n<li><code>OR</code> - bits.OR</li>\n<li><code>BETWEEN</code> - bits.BETWEEN (discussed in depth later)</li>\n<li><code>.IN(array)</code></li>\n<li><code>$</code> - bits.$ - used to specify that something is a parameter <code>$(params.foo)</code></li>\n</ul>\n<a name=\"joins\"></a><h3 id=\"joins\">Joins</h3>\n<p>With relational data, you will often need to join tables together, and to maintain good performance these joins may need to be optimized. SQLBits allows you to perform any joins you need (left, right, inner, outer) just like you would normally with raw SQL.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> query =\n SQL(<span class=\"hljs-string\">'select w.name, c.type from widgets w '</span> +\n   <span class=\"hljs-string\">'join category c on w.categoryID = c.categoryID'</span>)\n  .ORDERBY(<span class=\"hljs-string\">'w.name asc'</span>);\n\n<span class=\"hljs-comment\">// OR</span>\n\n<span class=\"hljs-keyword\">var</span> query =\n SQL(<span class=\"hljs-string\">'select w.name, c.type from widgets w'</span>)\n  ._(<span class=\"hljs-string\">'join category c on w.categoryID = c.categoryID'</span>)\n  .ORDERBY(<span class=\"hljs-string\">'w.name asc'</span>);\n\n<span class=\"hljs-comment\">// sql: select w.name, c.type from widgets w join category c on w.categoryID = c.categoryID ORDER BY w.name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n</code></pre>\n<p>The <code>._()</code> is another way to concatenate sql together.</p>\n<a name=\"filters_driven_by_defined_parameters\"></a><h3 id=\"filters-driven-by-defined-parameters\">Filters driven by defined parameters</h3>\n<p>If you have ever had to create SQL with filter clauses that was driven by user input, you should really appreciate this next feature.</p>\n<p>Let’s say for instance that you have a report or catalog that you want to allow the user to provide filter criteria to limit by.</p>\n<ul>\n<li>If the user doesn’t enter any criteria then return the whole list unfiltered.</li>\n<li>If they add a minimum price use that in the filter</li>\n<li>If they add a maximum price limit the rows with that criteria</li>\n<li>If they include a clearance boolean, use that in the criteria</li>\n</ul>\n<p>Even in this simple example, there are many combinations of possible filters depending on whether the user enters any of the filter data points.</p>\n<p>If you were building this SQL by hand, typically you would create a series of <code>if</code> statements to conditionally include the filter, and you would build up an array of params which you have to manually keep track of.</p>\n<p>However with SQLBits this is child’s play. You only have to create one complex query that includes all the possible filter criteria, and SQLBits will eliminate the parts where the parameters involved are <code>undefined</code>.</p>\n<p>Also by using the <code>BETWEEN</code> command, SQLBits handles all four scenarios automatically:</p>\n<ul>\n<li>min and max are defined: <code>price BETWEEN $1 AND $2</code></li>\n<li>only min is defined: <code>price &gt;= $1</code></li>\n<li>only max is defined: <code>price &lt;= $1</code></li>\n<li>neither min or max is defined: the criteria is eliminated</li>\n</ul>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL;\n<span class=\"hljs-keyword\">var</span> $ = bits.$;\n<span class=\"hljs-keyword\">var</span> AND = bits.AND;\n<span class=\"hljs-keyword\">var</span> BETWEEN = bits.BETWEEN;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">queryByParam</span>(<span class=\"hljs-params\">params</span>) </span>{\n <span class=\"hljs-keyword\">var</span> query =\n  SQL(<span class=\"hljs-string\">'select name, desc from widgets'</span>)\n   .WHERE(<span class=\"hljs-string\">'price'</span>, BETWEEN(params.min, params.max), AND,\n       <span class=\"hljs-string\">'clearance = '</span>, $(params.clearance))\n   .ORDERBY(<span class=\"hljs-string\">'name asc'</span>);\n <span class=\"hljs-keyword\">return</span> query;\n}\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE(price BETWEEN $1 AND $2 AND clearance = $3) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, 10, true ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price &gt;=$1 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2 ];</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price &lt;=$1 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 10 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">10.00</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE price BETWEEN $1 AND $2 ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, 10 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = queryByParam({ <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">2.00</span>, <span class=\"hljs-attr\">clearance</span>: <span class=\"hljs-literal\">true</span> });\n<span class=\"hljs-comment\">// sql: select name, desc from widgets WHERE(price &gt;=$1 AND clearance = $2) ORDER BY name asc</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 2, true ]</span>\n</code></pre>\n<p>In my opinion, this is one of the killer features of SQLBits. You create a single complex query with all the possible filters and then just provide a params object to SQLBits with a parameters object having the keys that the user wants to filter by, and it provides the customized query.</p>\n<p>This eliminates all the conditional logic which is hard to test and debug when it fails and you are left with a single complex query to maintain.</p>\n<a name=\"inserts\"></a><h3 id=\"inserts\">Inserts</h3>\n<p>Inserting data into your tables by key is as simple as providing an object to SQLBits and it will add all the keys and values.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> INSERT = bits.INSERT;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">insertWidget</span>(<span class=\"hljs-params\">obj</span>) </span>{\n <span class=\"hljs-keyword\">return</span> INSERT.INTO(<span class=\"hljs-string\">'widgets'</span>, obj);\n}\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-attr\">desc</span>: <span class=\"hljs-string\">'Foo man'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">23.45</span> });\n<span class=\"hljs-comment\">//INSERT INTO widgets (name,desc,price) SELECT $1,$2,$3</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 'foo', 'Foo man', 23.45 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">11.23</span> });\n<span class=\"hljs-comment\">//INSERT INTO widgets (name,price) SELECT $1,$2</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: [ 'bar', 11.23 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = insertWidget({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span> });\n<span class=\"hljs-comment\">// INSERT INTO widgets (name) SELECT $1</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// params: ['bar']</span>\n</code></pre>\n<a name=\"updates\"></a><h3 id=\"updates\">Updates</h3>\n<p>Updating data works just like the inserts but uses the <code>UPDATE</code> and <code>.SET()</code></p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> UPDATE = bits.UPDATE;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateWidget</span>(<span class=\"hljs-params\">id, updateValues</span>) </span>{\n <span class=\"hljs-keyword\">return</span> UPDATE(<span class=\"hljs-string\">'widget'</span>)\n      .SET(updateValues)\n      ._(<span class=\"hljs-string\">'where id='</span>, $(id));\n}\n\n<span class=\"hljs-keyword\">var</span> query = updateWidget(<span class=\"hljs-number\">1</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bar'</span> });\n<span class=\"hljs-comment\">// sql: UPDATE widget SET name=$1 where id=$2</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 'bar', 1 ]</span>\n\n<span class=\"hljs-keyword\">var</span> query = updateWidget(<span class=\"hljs-number\">2</span>, { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'cat'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">1.12</span> });\n<span class=\"hljs-comment\">// UPDATE widget SET name=$1,price=$2 where id=$3</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 'cat', 1.12, 2 ]</span>\n</code></pre>\n<p>Note: with update’s we don’t want to have the WHERE clause collapse so it is safer to use a non-conditional string with <code>._(&#39;where id = &#39;, $(obj.id))</code> to there is no chance of the filter clause being collapsed.</p>\n<a name=\"deletes\"></a><h3 id=\"deletes\">Deletes</h3>\n<p>Finally deletes use <code>DELETE.FROM</code> to specify a deletion.</p>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> DELETE = bits.DELETE;\n<span class=\"hljs-keyword\">var</span> params = { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">10</span> };\n\n<span class=\"hljs-keyword\">var</span> query = DELETE.FROM(<span class=\"hljs-string\">'widgets'</span>)\n       ._(<span class=\"hljs-string\">'where id='</span>, $(params.id));\n\n<span class=\"hljs-comment\">// sql: DELETE FROM widgets where id=$1</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'sql: '</span>, query.sql);\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'params: '</span>, query.params); <span class=\"hljs-comment\">// [ 10 ]</span>\n</code></pre>\n<p>Note: with delete’s we don’t want to have the WHERE clause collapse so it is safer to use a non-conditional string with <code>._(&#39;where id = &#39;, $(obj.id))</code> to there is no chance of the filter clause being collapsed.</p>\n<a name=\"quick_reference\"></a><h2 id=\"quick-reference\">Quick Reference</h2>\n<pre class=\"highlight\"><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> bits = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'sqlbits'</span>);\n<span class=\"hljs-keyword\">var</span> SQL = bits.SQL; <span class=\"hljs-comment\">// SQL('select name, desc from widgets')</span>\n<span class=\"hljs-keyword\">var</span> $ = bits.$; <span class=\"hljs-comment\">// SQL('...').WHERE('id=', $(obj.id));</span>\n<span class=\"hljs-keyword\">var</span> AND = bits.AND; <span class=\"hljs-comment\">// .WHERE('id=', $(obj.id), AND, 'type=', $(obj.type));</span>\n<span class=\"hljs-keyword\">var</span> OR = bits.OR; <span class=\"hljs-comment\">// .WHERE('type=', $(obj.type), OR, 'color=', $(obj.color));</span>\n<span class=\"hljs-keyword\">var</span> IN = bits.IN; <span class=\"hljs-comment\">// .WHERE('id', IN(array));</span>\n<span class=\"hljs-keyword\">var</span> BETWEEN = bits.BETWEEN; <span class=\"hljs-comment\">// .WHERE(price, BETWEEN($(obj.min), $(obj.max));</span>\n<span class=\"hljs-keyword\">var</span> INSERT = bits.INSERT; <span class=\"hljs-comment\">// INSERT.INTO('widgets', obj)</span>\n<span class=\"hljs-keyword\">var</span> UPDATE = bits.UPDATE; <span class=\"hljs-comment\">// UPDATE('widgets').SET(updateValues)._('where id = ', $(obj.id))</span>\n<span class=\"hljs-keyword\">var</span> DELETE = bits.DELETE; <span class=\"hljs-comment\">// DELETE.FROM('widgets')._('where id = ', $(obj.id))</span>\n</code></pre>\n<p>Methods to help chain</p>\n<ul>\n<li><code>._()</code> - appends to the SQL after adding a space</li>\n<li><code>.WHERE(...)</code> - add a <code>where</code> clause which checks the params that are defined to conditionally add the filter criteria</li>\n<li><code>.SET(updateValues)</code> - used with <code>UPDATE</code> to provide the field names and values to update</li>\n<li><code>.FROM(&#39;mytable&#39;)</code> - used with <code>DELETE</code> to specify table</li>\n<li><code>.ORDERBY(&#39;name asc, qty desc&#39;)</code> - add sorting criteria</li>\n<li><code>.LIMIT(number)</code> - limit the max rows returned, defaults to 0</li>\n<li><code>.OFFSET(number)</code> - start rows at offset (for paging), defaults to 0</li>\n</ul>\n<p>Accessor properties</p>\n<ul>\n<li><code>.sql</code> - get the parameterized SQL string</li>\n<li><code>.params</code> - get the array of parameters to use with the SQL</li>\n</ul>\n<a name=\"resources\"></a><h2 id=\"resources\">Resources</h2>\n<ul>\n<li><a href=\"https://github.com/williamwicks/sqlbits\" title=\"SQLBits GitHub project page\">SQLBits</a> - GitHub repo and project readme. This brief page provides examples of how to use SQLBits and is a great place to get started</li>\n</ul>\n<a name=\"summary\"></a><h2 id=\"summary\">Summary</h2>\n<p>SQLBits is a nice lightweight way to create safe parameterized SQL for Postgres or other ANSI SQL databases. It focuses on simply helping you build the SQL by managing the parameterization process, but you can still use the full power of SQL to create optimized queries and even special features that a particular SQL engine provides.</p>\n<p>One of its killer features is the ability to create custom filter queries based on whether parameters are defined, so you can create one complex query which is relaxed based on the parameters defined at runtime.</p>\n<p>Check out SQLBits, and let me know what you think. You can leave a comment in the discussion secion of this episode. I find it to be a great tool to help me generate SQL for Postgres and hope you will too.</p></p>\r\n  </div>\r\n</div>","author":"Chris Love","facebook-publisher":"https://www.facebook.com/Love2Dev/","twitter":"ChrisLove","google-plus":"https://plus.google.com/b/110904107389779237581/?pageId=110904107389779237581","linkedin":"https://www.linkedin.com/in/Love2Dev/","pinterest":"https://www.pinterest.com/docluv/","youtube":"https://www.youtube.com/channel/UC3mfh2MN-5D-zOyiRLp9H6g","bing-user-key":"7EDAB92AF63E3B35E57195D810D64C57","image":{"url":"http://codewinds.com/assets/codewinds/codewinds-podcast-300.png","width":300,"height":300},"cache":{},"headers":{"Cache-Control":"public, max-age=30240, s-max-age=1200"},"meta":{"type":"article","og:type":"article","section":"progressive web apps","url":"https://podstr.love2dev.com/","route":"/"},"subtitle":null,"featured-image":"img/pwa-podstr-logo-600x310.png","abstract":"<img align='left' src='img/pwa-podstr-logo-600x310.png' style='margin: 18px 18px 18px 6px; float: left; display: inline' lazyload='1' lazyload='1' />Two years, it&#39;s hard to comprehend how fast the time has flown and how much my life has changed. November 2 marked my two year anniversary with Tellago and I thought I would try to express what these past two years have been like today, Thanksgiving. Back in July 2010, after about 8 months after joining Tellago I wrote about my experiences and thankfulness at the time. ","approved":true,"published":"2014-02-17T07:00:00.000Z","active":true,"tags":[],"publishedDay":20,"publishedMonth":10,"publishedYear":2117,"pubdate":"2014-02-17T07:00:00.000Z","link":"https://api.spreaker.com/download/episode/8734727/ep105_mixdown.mp3","guid":"http://codewinds.com/podcast/003.html","podcast":{"title":"CodeWinds - Leading edge web developer news and training | javascript / React.js / Node.js / HTML5 / web development - Jeff Barczewski","description":"Keep up with the latest web developer technologies and news covering javascript, React.js, Node.js, HTML5. Learn the current best practices in web and mobile app development.","image":"http://codewinds.com/assets/codewinds/codewinds-podcast-1400.png"}}